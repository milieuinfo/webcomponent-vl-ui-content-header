/**
 * Lightbox
 **/
import GenerateGallery from './generate-gallery';
import PhotoSwipe from 'photoswipe';
// eslint-disable-next-line
import PhotoSwipeUI_Default from 'photoswipe/dist/photoswipe-ui-default';
/**
 * Private Variables
 */
const lightboxClass = `js-${vl.ns}lightbox`,
  lightboxCaptionClass = `js-${vl.ns}lightbox-caption`,
  pswpClass = `${vl.ns}pswp`,
  lbLink = `${vl.ns}lightbox__link`,
  dataPrefix = `data-${vl.ns}`,
  lbAtt = `${dataPrefix}lightbox`,
  lbItemAtt = `${lbAtt}-item`,
  lbSizeAtt = `${lbAtt}-size`;

let pswpElement = null;
/**
 * Private Functions
 */
const _createLightbox = lb => {
  if (lb === null) {
    return false;
  }

  pswpElement = document.querySelector(`.${pswpClass}`);
  // If pswp container is available do nothing, else generate the necessary elements
  if (pswpElement === null) {
    pswpElement = new GenerateGallery();
  }

  lb.onclick = _onThumbnailsClick;
};

/**
 * parse slide data (url, title, size ...) from DOM elements
 * (children of gallerySelector)
 * @param el
 * @returns {Array}
 */
const _parseThumbnailElements = el => {
  const thumbElements = el.querySelectorAll(`[${lbItemAtt}]`);

  let items = [];

  vl.util.each(thumbElements, thumb => {
    let width = 0;
    let height = 0;

    if (thumb.hasAttribute(lbSizeAtt)) {
      const size = thumb.getAttribute(lbSizeAtt).split('x');

      width = parseInt(size[0], 10);
      height = parseInt(size[1], 10);
    }

    const item = {
      src: thumb.querySelector(`.${lbLink}`).getAttribute('href'),
      w: width,
      h: height
    };

    // Figcaption
    const figcaption = thumb.querySelector(`.${lightboxCaptionClass}`);

    if (figcaption) {
      item.title = figcaption.innerHTML;
    }

    const image = thumb.querySelector('img');

    if (image) {
      item.msrc = image.getAttribute('src');
    }

    item.el = thumb; // save link to element for getThumbBoundsFn
    items.push(item);
  });

  return items;
};

const _onThumbnailsClick = e => {
  e.preventDefault();

  const eTarget = e.target || e.srcElement;

  let clickedListItem = eTarget,
    nodeIndex = 0,
    index = 0;

  if (!eTarget.hasAttribute(lbItemAtt)) {
    clickedListItem = eTarget.closest(`[${lbItemAtt}]`);
  }

  if (!clickedListItem) {
    return;
  }

  // find index of clicked item by looping through all child nodes
  // alternatively, you may define index via data- attribute
  const clickedGallery = clickedListItem.closest(`.${lightboxClass}, [${lbAtt}]`),
    childNodes = clickedGallery.querySelectorAll(`[${lbItemAtt}]`),
    numChildNodes = childNodes.length;

  for (let i = 0; i < numChildNodes; i++) {
    if (childNodes[i].nodeType !== 1) {
      continue;
    }

    if (childNodes[i] === clickedListItem) {
      index = nodeIndex;
      break;
    }
    nodeIndex++;
  }
  // open PhotoSwipe if valid index found
  index >= 0 ? _openPhotoSwipe(index, clickedGallery) : null;

  return false;
};

/**
 * if no size is set, calculate own size
 * @param item
 */
const _calculateIdealSize = (item, instance) => {
  const baseHeight = instance.height;
  const baseWidth = instance.width;
  let calculatedBaseHeight;
  let calculatedBaseWidth;

  const viewportHeight = window.innerHeight;

  if (baseHeight > viewportHeight) {
    calculatedBaseHeight = viewportHeight;
    calculatedBaseWidth = (viewportHeight / baseHeight) * baseWidth;
  }

  item.h = calculatedBaseHeight;
  item.w = calculatedBaseWidth;
};

const _openPhotoSwipe = (index, galleryElement, disableAnimation, fromURL) => {
  let gallery, options, items;

  items = _parseThumbnailElements(galleryElement);
  options = {
    // define gallery index (for URL)
    galleryUID: galleryElement.getAttribute('data-pswp-uid'),
    history: false,
    getThumbBoundsFn: function(index) {
      // See Options -> getThumbBoundsFn section of documentation for more info
      const thumbnail = items[index].el.getElementsByTagName('img')[0]; // find thumbnail
      const pageYScroll =
        window.pageYOffset || document.documentElement.scrollTop;

      if (thumbnail) {
        const rect = thumbnail.getBoundingClientRect();

        return {x: rect.left, y: rect.top + pageYScroll, w: rect.width};
      }
      return false;
    },
    arrowKeys: true,
    showHideOpacity: true
  };

  // PhotoSwipe opened from URL
  if (fromURL) {
    if (options.galleryPIDs) {
      // parse real index when custom PIDs are used
      // http://photoswipe.com/documentation/faq.html#custom-pid-in-url
      for (let j = 0; j < items.length; j++) {
        if (items[j].pid === index) {
          options.index = j;
          break;
        }
      }
    } else {
      // in URL indexes start from 1
      options.index = parseInt(index, 10) - 1;
    }
  } else {
    options.index = parseInt(index, 10);
  }

  // exit if index not found
  if (isNaN(options.index)) {
    return;
  }

  if (disableAnimation) {
    options.showAnimationDuration = 0;
  }

  // Pass data to PhotoSwipe and initialize it
  gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options);

  gallery.listen('gettingData', function(index, item) {
    if (!item.w && !item.h) {
      if (item.w < 1 || item.h < 1) {
        const img = new Image();

        img.onload = function () {
          _calculateIdealSize(item, this);
          gallery.updateSize(true);
        };

        img.src = item.src;
      }
    }
  });
  gallery.init();
};

class LightBox {
  /**
   * dress one element
   * @param element
   */
  dress(element) {
    _createLightbox(element);
  }

  /**
   * dressAll function for the accordion functionality
   * @return {false}
   */
  dressAll() {
    const elements = document.querySelectorAll(
      `.${lightboxClass}:not([data-${vl.ns}js-dress="false"]),
      [${lbAtt}]:not([data-${vl.ns}js-dress="false"])`
    );

    vl.util.each(elements, (element, i) => {
      element.setAttribute('data-pswp-uid', i + 1);
      this.dress(element);
    });
  }
}

if(!('lightbox' in vl)) {
  vl.lightbox = new LightBox();
  window.addEventListener('load', (event) => {
    vl.lightbox.dressAll();
  });
}

export default LightBox;
